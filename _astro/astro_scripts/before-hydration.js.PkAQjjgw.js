import{z as d,w as f,j as b}from"../lit-html.t5Xi0LsG.js";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const v={boundAttributeSuffix:d.j,marker:d.P,markerMatch:d.A,HTML_RESULT:d.C,getTemplateHtml:d.M,overrideDirectiveResolve:(t,r)=>class extends t{_$AS(l,a){return r(this,a)}},setDirectiveClass(t,r){t._$litDirective$=r},getAttributePartCommittedValue:(t,r,l)=>{let a=f;return t.O=n=>a=n,t._$AI(r,t,l),a},connectedDisconnectable:t=>({...t,_$AU:!0}),resolveDirective:d.V,AttributePart:d.I,PropertyPart:d.U,BooleanAttributePart:d.H,EventPart:d.N,ElementPart:d.B,TemplateInstance:d.L,isIterable:d.R,ChildPart:d.D};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const p={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6};/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const A=t=>t===null||typeof t!="object"&&typeof t!="function",$=(t,r)=>r===void 0?t?._$litType$!==void 0:t?._$litType$===r,E=t=>t?._$litType$?.h!=null,T=t=>t.strings===void 0;/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{TemplateInstance:w,isIterable:P,resolveDirective:m,ChildPart:h,ElementPart:g}=v,_=(t,r,l={})=>{if(r._$litPart$!==void 0)throw Error("container already contains a live render");let a,n,o;const e=[],c=document.createTreeWalker(r,NodeFilter.SHOW_COMMENT);let i;for(;(i=c.nextNode())!==null;){const s=i.data;if(s.startsWith("lit-part")){if(e.length===0&&a!==void 0)throw Error(`There must be only one root part per container. Found a part marker (${i}) when we already have a root part marker (${n})`);o=x(t,i,e,l),a===void 0&&(a=o),n??=i}else if(s.startsWith("lit-node"))R(i,e,l);else if(s.startsWith("/lit-part")){if(e.length===1&&o!==a)throw Error("internal error");o=I(i,o,e)}}if(a===void 0){const s=r instanceof ShadowRoot?"{container.host.localName}'s shadow root":r instanceof DocumentFragment?"DocumentFragment":r.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${s}.`)}r._$litPart$=a},x=(t,r,l,a)=>{let n,o;if(l.length===0)o=new h(r,null,void 0,a),n=t;else{const e=l[l.length-1];if(e.type==="template-instance")o=new h(r,null,e.instance,a),e.instance._$AV.push(o),n=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if(e.type==="iterable"){o=new h(r,null,e.part,a);const c=e.iterator.next();if(c.done)throw n=void 0,e.done=!0,Error("Unhandled shorter than expected iterable");n=c.value,e.part._$AH.push(o)}else o=new h(r,null,e.part,a)}if(n=m(o,n),n===f)l.push({part:o,type:"leaf"});else if(A(n))l.push({part:o,type:"leaf"}),o._$AH=n;else if($(n)){if(E(n))throw Error("compiled templates are not supported");const e="lit-part "+C(n);if(r.data!==e)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const c=h.prototype._$AC(n),i=new w(c,o);l.push({type:"template-instance",instance:i,part:o,templatePartIndex:0,instancePartIndex:0,result:n}),o._$AH=i}}else P(n)?(l.push({part:o,type:"iterable",value:n,iterator:n[Symbol.iterator](),done:!1}),o._$AH=[]):(l.push({part:o,type:"leaf"}),o._$AH=n??"");return o},I=(t,r,l)=>{if(r===void 0)throw Error("unbalanced part marker");r._$AB=t;const a=l.pop();if(a.type==="iterable"&&!a.iterator.next().done)throw Error("unexpected longer than expected iterable");if(l.length>0)return l[l.length-1].part},R=(t,r,l)=>{const a=/lit-node (\d+)/.exec(t.data),n=parseInt(a[1]),o=t.nextElementSibling;if(o===null)throw Error("could not find node for attribute parts");o.removeAttribute("defer-hydration");const e=r[r.length-1];if(e.type!=="template-instance")throw Error("Hydration value mismatch: Primitive found where TemplateResult expected. This usually occurs due to conditional rendering that resulted in a different value or template being rendered between the server and client.");{const c=e.instance;for(;;){const i=c._$AD.parts[e.templatePartIndex];if(i===void 0||i.type!==p.ATTRIBUTE&&i.type!==p.ELEMENT||i.index!==n)break;if(i.type===p.ATTRIBUTE){const s=new i.ctor(o,i.name,i.strings,e.instance,l),u=T(s)?e.result.values[e.instancePartIndex]:e.result.values,y=!(s.type===p.EVENT||s.type===p.PROPERTY);s._$AI(u,s,e.instancePartIndex,y),e.instancePartIndex+=i.strings.length-1,c._$AV.push(s)}else{const s=new g(o,e.instance,l);m(s,e.result.values[e.instancePartIndex++]),c._$AV.push(s)}e.templatePartIndex++}}},C=t=>{const r=new Uint32Array(2).fill(5381);for(const a of t.strings)for(let n=0;n<a.length;n++)r[n%2]=33*r[n%2]^a.charCodeAt(n);const l=String.fromCharCode(...new Uint8Array(r.buffer));return btoa(l)};globalThis.litElementHydrateSupport=({LitElement:t})=>{const r=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t),"observedAttributes").get;Object.defineProperty(t,"observedAttributes",{get(){return[...r.call(this),"defer-hydration"]}});const l=t.prototype.attributeChangedCallback;t.prototype.attributeChangedCallback=function(e,c,i){e==="defer-hydration"&&i===null&&a.call(this),l.call(this,e,c,i)};const a=t.prototype.connectedCallback;t.prototype.connectedCallback=function(){this.hasAttribute("defer-hydration")||a.call(this)};const n=t.prototype.createRenderRoot;t.prototype.createRenderRoot=function(){return this.shadowRoot?(this._$AG=!0,this.shadowRoot):n.call(this)};const o=Object.getPrototypeOf(t.prototype).update;t.prototype.update=function(e){const c=this.render();if(o.call(this,e),this._$AG){this._$AG=!1;for(let i=0;i<this.attributes.length;i++){const s=this.attributes[i];if(s.name.startsWith("hydrate-internals-")){const u=s.name.slice(18);this.removeAttribute(u),this.removeAttribute(s.name)}}_(c,this.renderRoot,this.renderOptions)}else b(c,this.renderRoot,this.renderOptions)}};
